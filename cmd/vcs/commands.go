package main

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"syscall"
	"time"

	"golang.org/x/term"

	fileops "github.com/Telerallc/gamedev-vcs/internal/fileOps"
	"github.com/spf13/cobra"
)

var (
	apiClient      *APIClient
	currentProject string
)

type ProjectInfo struct {
	ID            string `json:"id"`
	Name          string `json:"name"`
	Description   string `json:"description"`
	DefaultBranch string `json:"default_branch"`
}

// Project represents a VCS project
type Project struct {
	ID            string      `json:"id"`
	Name          string      `json:"name"`
	Slug          string      `json:"slug"`
	Description   string      `json:"description"`
	IsPrivate     bool        `json:"is_private"`
	DefaultBranch string      `json:"default_branch"`
	OwnerID       *string     `json:"owner_id"`
	Settings      interface{} `json:"settings"`
	CreatedAt     string      `json:"created_at"`
	UpdatedAt     string      `json:"updated_at"`
}

type CommitInfo struct {
	ID        string    `json:"id"`
	Message   string    `json:"message"`
	AuthorID  string    `json:"author_id"`
	CreatedAt time.Time `json:"created_at"`
}

type FileInfo struct {
	Path        string `json:"path"`
	ContentHash string `json:"content_hash"`
	Size        int64  `json:"size"`
}

type CommitResult struct {
	ID        string `json:"id"`
	Message   string `json:"message"`
	AuthorID  string `json:"author_id"`
	CreatedAt string `json:"created_at"`
}

// VCS ignore patterns (UE5 template)
var defaultVCSIgnorePatterns = []string{
	"# Visual Studio 2015 user specific files",
	".vs/",
	"# Compiled Object files",
	"*.slo",
	"*.lo",
	"*.o",
	"*.obj",
	"# Precompiled Headers",
	"*.gch",
	"*.pch",
	"# Compiled Dynamic libraries",
	"*.so",
	"*.dylib",
	"*.dll",
	"# Fortran module files",
	"*.mod",
	"# Compiled Static libraries",
	"*.lai",
	"*.la",
	"*.a",
	"*.lib",
	"# Executables",
	"*.exe",
	"*.out",
	"*.app",
	"*.ipa",
	"# These project files can be generated by the engine",
	"*.xcodeproj",
	"*.xcworkspace",
	"*.sln",
	"*.suo",
	"*.opensdf",
	"*.sdf",
	"*.VC.db",
	"*.VC.opendb",
	"# Precompiled Assets",
	"SourceArt/**/*.png",
	"SourceArt/**/*.tga",
	"# Binary Files",
	"Binaries/*",
	"Plugins/**/Binaries/*",
	"# Builds",
	"Build/*",
	"# Whitelist PakBlacklist-<BuildConfiguration>.txt files",
	"!Build/*/",
	"Build/*/**",
	"!Build/*/PakBlacklist*.txt",
	"# Don't ignore icon files in Build",
	"!Build/**/*.ico",
	"# Built data for maps",
	"*_BuiltData.uasset",
	"# Configuration files generated by the Editor",
	"Saved/*",
	"# Compiled source files for the engine to use",
	"Intermediate/*",
	"Plugins/**/Intermediate/*",
	"# Cache files for the editor to use",
	"DerivedDataCache/*",
	"# VCS specific",
	".vcs/",
	"*.tmp",
	"*.log",
}

func initializeClient() error {
	client, err := NewAPIClient(serverURL)
	if err != nil {
		return fmt.Errorf("failed to create API client: %w", err)
	}

	apiClient = client

	// Load auth token if it exists
	if token, sessionID, err := loadSavedCredentials(); err == nil {
		apiClient.SetAuth(token, sessionID)
	}

	return nil
}

func TestAuthentication() error {
	if apiClient == nil {
		return fmt.Errorf("no API client")
	}

	// Test auth by making a simple API call
	_, err := apiClient.makeRequest("GET", "/api/v1/projects", nil)
	return err
}

// testServerConnectivity tests if the VCS server is reachable
func testServerConnectivity() error {
	// Create a temporary client to test connectivity
	tempClient, err := NewAPIClient(serverURL)
	if err != nil {
		return fmt.Errorf("failed to create API client: %w", err)
	}

	// Try to make a simple request to test connectivity
	_, err = tempClient.makeRequest("GET", "/api/v1/health", nil)
	if err != nil {
		return fmt.Errorf("server not reachable at %s: %w", serverURL, err)
	}

	return nil
}

func saveCredentials(token, sessionID string) error {
	credPath := getCredentialsPath()

	// Create directory if it doesn't exist
	if err := os.MkdirAll(filepath.Dir(credPath), 0700); err != nil {
		return err
	}

	creds := struct {
		Token     string    `json:"token"`
		SessionID string    `json:"session_id"`
		ExpiresAt time.Time `json:"expires_at"`
		SavedAt   time.Time `json:"saved_at"`
	}{
		Token:     token,
		SessionID: sessionID,
		ExpiresAt: time.Now().Add(23 * time.Hour), // Expire 1 hour before actual token
		SavedAt:   time.Now(),
	}

	data, err := json.MarshalIndent(creds, "", "  ")
	if err != nil {
		return err
	}

	return os.WriteFile(credPath, data, 0600)
}

func getCredentialsPath() string {
	home, err := os.UserHomeDir()
	if err != nil {
		return ".vcs-credentials"
	}
	return filepath.Join(home, ".vcs", "credentials.json")
}

func loadSavedCredentials() (string, string, error) {
	credPath := getCredentialsPath()

	data, err := os.ReadFile(credPath)
	if err != nil {
		return "", "", err
	}

	var creds struct {
		Token     string    `json:"token"`
		SessionID string    `json:"session_id"`
		ExpiresAt time.Time `json:"expires_at"`
		Username  string    `json:"username"`
	}

	if err := json.Unmarshal(data, &creds); err != nil {
		return "", "", err
	}

	// Check if token is expired
	if time.Now().After(creds.ExpiresAt) {
		return "", "", fmt.Errorf("token expired")
	}

	return creds.Token, creds.SessionID, nil
}

func logoutCmd() *cobra.Command {
	return &cobra.Command{
		Use:   "logout",
		Short: "Logout and clear saved credentials",
		RunE: func(cmd *cobra.Command, args []string) error {
			credPath := getCredentialsPath()

			if err := os.Remove(credPath); err != nil && !os.IsNotExist(err) {
				return fmt.Errorf("failed to remove credentials: %w", err)
			}

			fmt.Println("‚úÖ Logged out successfully")
			return nil
		},
	}
}

func loginCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "login",
		Short: "Login to VCS server using Google OAuth",
		Long: `Login to VCS server using Google OAuth authentication.
This is the default and recommended authentication method.

Examples:
  vcs login                    # Google OAuth login (default)
  vcs login --password         # Username/password login (legacy)`,
		RunE: func(cmd *cobra.Command, args []string) error {
			fmt.Printf("üåê Connecting to VCS server at: %s\n", serverURL)

			// Test server connectivity first
			if err := testServerConnectivity(); err != nil {
				return err
			}

			// Check if password login is requested
			usePassword, _ := cmd.Flags().GetBool("password")
			if usePassword {
				return performPasswordLogin()
			}

			// Default to Google OAuth
			return performGoogleLogin()
		},
	}

	cmd.Flags().Bool("password", false, "Use username/password login instead of Google OAuth")
	return cmd
}

// performPasswordLogin handles username/password authentication
func performPasswordLogin() error {
	fmt.Printf("üîê Using username/password login...\n")

	// Clear any existing credentials
	credPath := getCredentialsPath()
	os.Remove(credPath)

	// Force new authentication
	apiClient = nil
	return initializeClient()
}

func performGoogleLogin() error {
	fmt.Printf("üîê Starting Google OAuth login...\n")

	// Create API client
	var err error
	apiClient, err = NewAPIClient(serverURL)
	if err != nil {
		return fmt.Errorf("failed to create API client: %w", err)
	}

	// Start local callback server FIRST
	callbackChan := make(chan OAuthCallback, 1)
	localServer, localPort := startLocalCallbackServer(callbackChan)
	defer localServer.Close()

	// Use local callback URL
	localCallbackURL := fmt.Sprintf("http://localhost:%d/callback", localPort)

	// Initiate Google OAuth with local callback URL
	oauthURL := fmt.Sprintf("/api/v1/auth/google?callback_url=%s", url.QueryEscape(localCallbackURL))
	resp, err := apiClient.makeRequest("GET", oauthURL, nil)
	if err != nil {
		return fmt.Errorf("failed to initiate Google login: %w", err)
	}

	var oauthResp struct {
		Success bool   `json:"success"`
		AuthURL string `json:"auth_url"`
		State   string `json:"state"`
		Error   string `json:"error"`
	}

	if err := json.Unmarshal(resp, &oauthResp); err != nil {
		return fmt.Errorf("failed to parse OAuth response: %w", err)
	}

	if !oauthResp.Success {
		return fmt.Errorf("failed to initiate OAuth: %s", oauthResp.Error)
	}

	fmt.Printf("üåê Opening browser for Google authentication...\n")
	fmt.Printf("üîó If browser doesn't open, visit: %s\n", oauthResp.AuthURL)

	// Open browser
	if err := openBrowser(oauthResp.AuthURL); err != nil {
		fmt.Printf("‚ö†Ô∏è  Could not open browser automatically: %v\n", err)
		fmt.Printf("Please manually open: %s\n", oauthResp.AuthURL)
	}

	fmt.Printf("\n‚è≥ Waiting for authentication...\n")
	fmt.Printf("üí° Complete the login in your browser - no need to copy anything!\n")

	// Wait for callback with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()

	select {
	case callback := <-callbackChan:
		if callback.Error != "" {
			return fmt.Errorf("OAuth error: %s", callback.Error)
		}
		return completeGoogleLogin(callback.Code, callback.State)

	case <-ctx.Done():
		return fmt.Errorf("authentication timeout - please try again")
	}
}

type OAuthCallback struct {
	Code  string
	State string
	Error string
}

func startLocalCallbackServer(callbackChan chan<- OAuthCallback) (*http.Server, int) {
	// Try multiple ports in case 8081 is busy
	ports := []int{8081, 8082, 8083, 8084, 8085}

	for _, port := range ports {
		mux := http.NewServeMux()

		mux.HandleFunc("/callback", func(w http.ResponseWriter, r *http.Request) {
			code := r.URL.Query().Get("code")
			state := r.URL.Query().Get("state")
			errorParam := r.URL.Query().Get("error")

			// Debug logging
			if verbose {
				fmt.Printf("Callback received - Code: %s, State: %s, Error: %s\n",
					func() string {
						if code != "" {
							return code[:20] + "..."
						} else {
							return "EMPTY"
						}
					}(),
					func() string {
						if state != "" {
							return state[:20] + "..."
						} else {
							return "EMPTY"
						}
					}(),
					errorParam)
			}

			// Send callback data to channel
			callbackChan <- OAuthCallback{
				Code:  code,
				State: state,
				Error: errorParam,
			}

			// Show success page
			if errorParam != "" {
				w.Header().Set("Content-Type", "text/html")
				fmt.Fprintf(w, `
					<html><body style="font-family: Arial, sans-serif; text-align: center; padding: 50px;">
						<h2 style="color: #e74c3c;">‚ùå Authentication Failed</h2>
						<p>Error: %s</p>
						<p>Please close this window and try again in your terminal.</p>
					</body></html>
				`, errorParam)
			} else {
				w.Header().Set("Content-Type", "text/html")
				fmt.Fprintf(w, `
					<html><body style="font-family: Arial, sans-serif; text-align: center; padding: 50px;">
						<h2 style="color: #27ae60;">Authentication Successful!</h2>
						<p>You can now close this window and return to your terminal.</p>
						<script>setTimeout(() => window.close(), 30);</script>
					</body></html>
				`)
			}
		})

		server := &http.Server{
			Addr:    fmt.Sprintf(":%d", port),
			Handler: mux,
		}

		// Try to start server on this port
		go func(currentPort int) {
			if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
				if verbose {
					fmt.Printf("Port %d unavailable: %v\n", currentPort, err)
				}
			}
		}(port)

		// Give it a moment to start
		time.Sleep(200 * time.Millisecond)

		// Test if server started successfully by making a test connection
		conn, err := net.DialTimeout("tcp", fmt.Sprintf("localhost:%d", port), 1*time.Second)
		if err == nil {
			conn.Close()
			fmt.Printf("Local callback server started on port %d\n", port)
			return server, port
		}
	}

	panic("Could not start local callback server on any available port")
}

// completeGoogleLogin completes the OAuth flow
func completeGoogleLogin(code, state string) error {
	fmt.Printf("üîÑ Completing authentication...\n")

	// Debug logging
	if verbose {
		fmt.Printf("Code: %s...\n", code[:20])
		fmt.Printf("State: %s...\n", state[:20])
	}

	// Make sure we have valid code and state
	if code == "" || state == "" {
		return fmt.Errorf("missing authorization code or state parameter")
	}

	// Send callback request to server's callback endpoint
	callbackURL := fmt.Sprintf("/api/v1/auth/google/callback?code=%s&state=%s",
		url.QueryEscape(code), url.QueryEscape(state))

	resp, err := apiClient.makeRequest("GET", callbackURL, nil)
	if err != nil {
		return fmt.Errorf("OAuth callback failed: %w", err)
	}

	var loginResp struct {
		Success      bool   `json:"success"`
		Token        string `json:"token"`
		RefreshToken string `json:"refresh_token"`
		User         struct {
			ID       string `json:"id"`
			Username string `json:"username"`
			Email    string `json:"email"`
			Name     string `json:"name"`
		} `json:"user"`
		IsNewUser  bool   `json:"is_new_user"`
		AuthMethod string `json:"auth_method"`
		Error      string `json:"error"`
	}

	if err := json.Unmarshal(resp, &loginResp); err != nil {
		return fmt.Errorf("failed to parse login response: %w", err)
	}

	if !loginResp.Success {
		return fmt.Errorf("google login failed: %s", loginResp.Error)
	}

	// Save credentials
	apiClient.SetAuth(loginResp.Token, "")
	if err := saveCredentials(loginResp.Token, ""); err != nil {
		fmt.Printf("Warning: failed to save credentials: %v\n", err)
	}

	// Show welcome message
	if loginResp.IsNewUser {
		fmt.Printf("üéâ Welcome to VCS! New account created.\n")
	} else {
		fmt.Printf("‚úÖ Welcome back!\n")
	}

	fmt.Printf("üë§ Logged in as: %s (%s)\n", loginResp.User.Name, loginResp.User.Username)
	fmt.Printf("üìß Email: %s\n", loginResp.User.Email)
	fmt.Printf("üîê Auth method: %s\n", loginResp.AuthMethod)

	if verbose {
		fmt.Printf("ü™™  User ID: %s\n", loginResp.User.ID)
	}

	return nil
}

// openBrowser opens the default browser with the given URL
func openBrowser(url string) error {
	var cmd string
	var args []string

	switch runtime.GOOS {
	case "windows":
		cmd = "cmd"
		args = []string{"/c", "start"}
	case "darwin":
		cmd = "open"
	default: // "linux", "freebsd", "openbsd", "netbsd"
		cmd = "xdg-open"
	}
	args = append(args, url)
	return exec.Command(cmd, args...).Start()
}

// Add whoami command to check current user
func whoamiCmd() *cobra.Command {
	return &cobra.Command{
		Use:   "whoami",
		Short: "Show current user information",
		RunE: func(cmd *cobra.Command, args []string) error {
			if err := initializeClient(); err != nil {
				return err
			}

			resp, err := apiClient.makeRequest("GET", "/api/v1/auth/me", nil)
			if err != nil {
				return fmt.Errorf("failed to get user info: %w", err)
			}

			var userResp struct {
				Success bool `json:"success"`
				User    struct {
					ID       string `json:"id"`
					Username string `json:"username"`
					Email    string `json:"email"`
					Name     string `json:"name"`
				} `json:"user"`
			}

			if err := json.Unmarshal(resp, &userResp); err != nil {
				return fmt.Errorf("failed to parse user response: %w", err)
			}

			if !userResp.Success {
				return fmt.Errorf("failed to get user info")
			}

			fmt.Printf("üë§ Current User:\n")
			fmt.Printf("   Name: %s\n", userResp.User.Name)
			fmt.Printf("   Username: %s\n", userResp.User.Username)
			fmt.Printf("   Email: %s\n", userResp.User.Email)
			fmt.Printf("   ID: %s\n", userResp.User.ID)
			fmt.Printf("   Server: %s\n", serverURL)

			// Check credentials location
			credPath := getCredentialsPath()
			if _, err := os.Stat(credPath); err == nil {
				fmt.Printf("   Credentials: Saved locally\n")
			} else {
				fmt.Printf("   Credentials: Session only\n")
			}

			return nil
		},
	}
}

// Enhanced command implementations with backend integration

func initCmd() *cobra.Command {
	var projectName string
	var description string
	var isPrivate bool
	var force bool

	cmd := &cobra.Command{
		Use:   "init [project-name]",
		Short: "Initialize a new VCS repository",
		Long: `Initialize a new VCS repository in the current directory.
Creates local .vcs directory structure, .vcsignore file, and registers project with VCS server.

Examples:
  vcs init                              # Initialize with directory name as project
  vcs init MyProject                    # Initialize with specific project name
  vcs init MyProject --private          # Initialize as private project
  vcs init --description "My UE5 game"  # Initialize with description`,
		Args: cobra.MaximumNArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			if len(args) > 0 {
				projectName = args[0]
			}
			return runVCSInit(projectName, description, isPrivate, force)
		},
	}

	cmd.Flags().StringVarP(&description, "description", "d", "", "Project description")
	cmd.Flags().BoolVarP(&isPrivate, "private", "p", true, "Make project private (default: true)")
	cmd.Flags().BoolVar(&force, "force", false, "Force initialization even if VCS already exists")

	return cmd
}

func addCmd() *cobra.Command {
	var addAll bool
	var verbose bool

	cmd := &cobra.Command{
		Use:   "add [files...]",
		Short: "Add files to the staging area",
		Long: `Add files to the staging area for the next commit.
		
Phase 1 Optimizations:
- Git-style stat optimization (only processes changed files)
- Content-addressable object storage
- Batch processing for maximum efficiency
- Local object deduplication

Examples:
  vcs add file1.cpp file2.h         # Add specific files
  vcs add -a                        # Add all files (respecting .vcsignore)
  vcs add --verbose -a              # Show detailed processing info`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runAddGitStyle(args, addAll, verbose)
		},
	}

	cmd.Flags().BoolVarP(&addAll, "all", "a", false, "Add all files")
	cmd.Flags().BoolVarP(&verbose, "verbose", "v", false, "Show detailed processing information")

	return cmd
}

// Helper function to load project config
func LoadProjectConfig() (map[string]interface{}, error) {
	// Check if .vcs directory exists
	if _, err := os.Stat(".vcs"); os.IsNotExist(err) {
		return nil, fmt.Errorf(".vcs directory not found")
	}

	// Try to load project.json (new format)
	if data, err := os.ReadFile(".vcs/project.json"); err == nil {
		var config map[string]interface{}
		if err := json.Unmarshal(data, &config); err != nil {
			return nil, fmt.Errorf("invalid project.json format: %w", err)
		}
		return config, nil
	}

	// Fallback: try to load old config.json and convert it
	if data, err := os.ReadFile(".vcs/config.json"); err == nil {
		var oldConfig map[string]interface{}
		if err := json.Unmarshal(data, &oldConfig); err != nil {
			return nil, fmt.Errorf("invalid config.json format: %w", err)
		}

		// Convert old format to new format if possible
		if projectName, ok := oldConfig["project_name"].(string); ok {
			fmt.Println("‚ö†Ô∏è  Warning: Using old VCS format. Run 'vcs init --force' to upgrade.")
			return map[string]interface{}{
				"project_id":     projectName, // Use project name as fallback ID
				"project_name":   projectName,
				"default_branch": "main",
			}, nil
		}
	}

	return nil, fmt.Errorf("no valid VCS configuration found")
}

func statusCmd() *cobra.Command {
	var verbose bool

	cmd := &cobra.Command{
		Use:   "status",
		Short: "Show working tree status with Git-style optimizations",
		Long: `Show the status of files in the working tree.

Phase 1 Features:
- Git-style stat optimization for change detection
- Local object store statistics
- Index health information
- Compression statistics`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runStatusGitStyle(verbose)
		},
	}

	cmd.Flags().BoolVarP(&verbose, "verbose", "v", false, "Show detailed status information")

	return cmd
}

func lockCmd() *cobra.Command {
	return &cobra.Command{
		Use:   "lock <file>",
		Short: "Lock a file for exclusive editing",
		Args:  cobra.ExactArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			if err := initializeClient(); err != nil {
				return err
			}

			// Load current project from config or use default
			if currentProject == "" {
				if config, err := LoadProjectConfig(); err == nil {
					if projectName, ok := config["project_name"].(string); ok {
						currentProject = projectName
					}
				}
				if currentProject == "" {
					currentProject = "default"
				}
			}

			filePath := args[0]

			if verbose {
				fmt.Printf("Locking file: %s in project: %s\n", filePath, currentProject)
			}

			result, err := apiClient.LockFile(currentProject, filePath)
			if err != nil {
				return fmt.Errorf("failed to lock file: %w", err)
			}

			if !result.Locked {
				fmt.Printf("‚ùå Failed to lock %s: %s\n", filePath, result.Error)
				return nil
			}

			fmt.Printf("‚úÖ Locked %s\n", filePath)

			if result.LockInfo != nil {
				if expiresAt, ok := result.LockInfo["expires_at"].(string); ok {
					if expTime, err := time.Parse(time.RFC3339, expiresAt); err == nil {
						fmt.Printf("   Expires: %s\n", formatTime(expTime))
					}
				}
			}

			// Update presence to editing
			apiClient.UpdatePresence(currentProject, "editing", filePath)

			return nil
		},
	}
}

func unlockCmd() *cobra.Command {
	return &cobra.Command{
		Use:   "unlock <file>",
		Short: "Unlock a file",
		Args:  cobra.ExactArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			if err := initializeClient(); err != nil {
				return err
			}

			if currentProject == "" {
				currentProject = "default"
			}

			filePath := args[0]

			if verbose {
				fmt.Printf("Unlocking file: %s\n", filePath)
			}

			err := apiClient.UnlockFile(currentProject, filePath)
			if err != nil {
				return fmt.Errorf("failed to unlock file: %w", err)
			}

			fmt.Printf("üîì Unlocked %s\n", filePath)

			// Update presence to online
			apiClient.UpdatePresence(currentProject, "online", "")

			return nil
		},
	}
}

func analyticsCmd() *cobra.Command {
	var days int
	var limit int
	var assetPath string

	cmd := &cobra.Command{
		Use:   "analytics",
		Short: "Show project analytics",
		RunE: func(cmd *cobra.Command, args []string) error {
			if err := initializeClient(); err != nil {
				return err
			}

			if currentProject == "" {
				currentProject = "default"
			}

			// Get productivity metrics
			fmt.Printf("üìä Team Productivity (last %d days):\n", days)
			productivityResp, err := apiClient.GetProductivityMetrics(currentProject, days)
			if err != nil {
				fmt.Printf("‚ùå Failed to get productivity metrics: %v\n", err)
			} else {
				var productivity struct {
					Metrics []map[string]interface{} `json:"metrics"`
				}

				if err := json.Unmarshal(productivityResp, &productivity); err == nil {
					if len(productivity.Metrics) == 0 {
						fmt.Println("   No activity in the specified period")
					} else {
						for _, metric := range productivity.Metrics {
							if author, ok := metric["author"].(string); ok {
								if commits, ok := metric["commits_count"].(float64); ok {
									if files, ok := metric["files_changed"].(float64); ok {
										fmt.Printf("   üë§ %s: %.0f commits, %.0f files changed\n",
											author, commits, files)
									}
								}
							}
						}
					}
				}
			}

			// Get activity feed
			fmt.Printf("\nüìà Recent Activity (last %d events):\n", limit)
			activityResp, err := apiClient.GetActivityFeed(currentProject, limit)
			if err != nil {
				fmt.Printf("‚ùå Failed to get activity feed: %v\n", err)
			} else {
				var activity struct {
					Activities []map[string]interface{} `json:"activities"`
				}

				if err := json.Unmarshal(activityResp, &activity); err == nil {
					if len(activity.Activities) == 0 {
						fmt.Println("   No recent activity")
					} else {
						for _, event := range activity.Activities {
							if eventType, ok := event["event_type"].(string); ok {
								if userName, ok := event["user_name"].(string); ok {
									if filePath, ok := event["file_path"].(string); ok {
										if eventTime, ok := event["event_time"].(string); ok {
											if t, err := time.Parse(time.RFC3339, eventTime); err == nil {
												icon := getEventIcon(eventType)
												fmt.Printf("   %s %s %s %s (%s)\n",
													icon, userName, eventType, filePath, formatTime(t))
											}
										}
									}
								}
							}
						}
					}
				}
			}

			// Get dependency info if asset specified
			if assetPath != "" {
				fmt.Printf("\nüîó Dependencies for %s:\n", assetPath)
				depResp, err := apiClient.GetDependencyGraph(currentProject, assetPath)
				if err != nil {
					fmt.Printf("‚ùå Failed to get dependencies: %v\n", err)
				} else {
					var deps struct {
						Dependencies []map[string]interface{} `json:"dependencies"`
						Dependents   []map[string]interface{} `json:"dependents"`
					}

					if err := json.Unmarshal(depResp, &deps); err == nil {
						if len(deps.Dependencies) > 0 {
							fmt.Println("   Dependencies:")
							for _, dep := range deps.Dependencies {
								if target, ok := dep["depends_on_path"].(string); ok {
									if depType, ok := dep["dependency_type"].(string); ok {
										fmt.Printf("     ‚Üí %s (%s)\n", target, depType)
									}
								}
							}
						}

						if len(deps.Dependents) > 0 {
							fmt.Println("   Dependents:")
							for _, dep := range deps.Dependents {
								if source, ok := dep["asset_path"].(string); ok {
									if depType, ok := dep["dependency_type"].(string); ok {
										fmt.Printf("     ‚Üê %s (%s)\n", source, depType)
									}
								}
							}
						}

						if len(deps.Dependencies) == 0 && len(deps.Dependents) == 0 {
							fmt.Println("   No dependencies found")
						}
					}
				}
			}

			return nil
		},
	}

	cmd.Flags().IntVar(&days, "days", 7, "Number of days for productivity metrics")
	cmd.Flags().IntVar(&limit, "limit", 10, "Number of recent activities to show")
	cmd.Flags().StringVar(&assetPath, "asset", "", "Asset path to analyze dependencies")

	return cmd
}

func watchCmd() *cobra.Command {
	return &cobra.Command{
		Use:   "watch",
		Short: "Watch for real-time collaboration events",
		RunE: func(cmd *cobra.Command, args []string) error {
			if err := initializeClient(); err != nil {
				return err
			}

			if currentProject == "" {
				currentProject = "default"
			}

			fmt.Printf("üîÑ Watching for real-time events in project: %s\n", currentProject)
			fmt.Printf("Press Ctrl+C to stop...\n\n")

			// Update presence to online
			apiClient.UpdatePresence(currentProject, "online", "")

			return apiClient.SubscribeToEvents(currentProject, func(event map[string]interface{}) {
				if eventType, ok := event["type"].(string); ok {
					if userName, ok := event["user_name"].(string); ok {
						timestamp := time.Now().Format("15:04:05")
						icon := getEventIcon(eventType)

						message := fmt.Sprintf("[%s] %s %s", timestamp, icon, userName)

						if filePath, ok := event["file_path"].(string); ok && filePath != "" {
							message += fmt.Sprintf(" %s %s", eventType, filePath)
						} else {
							message += fmt.Sprintf(" %s", eventType)
						}

						fmt.Println(message)
					}
				}
			})
		},
	}
}

func storageCmd() *cobra.Command {
	return &cobra.Command{
		Use:   "storage",
		Short: "Show storage statistics",
		RunE: func(cmd *cobra.Command, args []string) error {
			if err := initializeClient(); err != nil {
				return err
			}

			resp, err := apiClient.GetStorageStats()
			if err != nil {
				return fmt.Errorf("failed to get storage stats: %w", err)
			}

			var stats struct {
				Success bool                   `json:"success"`
				Stats   map[string]interface{} `json:"stats"`
			}

			if err := json.Unmarshal(resp, &stats); err != nil {
				return fmt.Errorf("failed to parse storage stats: %w", err)
			}

			fmt.Println("üíæ Storage Statistics:")

			if totalFiles, ok := stats.Stats["total_files"].(float64); ok {
				fmt.Printf("   Total Files: %.0f\n", totalFiles)
			}

			if totalSize, ok := stats.Stats["total_size"].(float64); ok {
				fmt.Printf("   Total Size: %s\n", FormatFileSize(int64(totalSize)))
			}

			if basePath, ok := stats.Stats["base_path"].(string); ok {
				fmt.Printf("   Storage Path: %s\n", basePath)
			}

			return nil
		},
	}
}

func cloneCmd() *cobra.Command {
	var branch string
	var shallow bool

	cmd := &cobra.Command{
		Use:   "clone <project-id> [directory]",
		Short: "Clone a project from the server",
		Args:  cobra.RangeArgs(1, 2),
		RunE: func(cmd *cobra.Command, args []string) error {
			if err := initializeClient(); err != nil {
				return err
			}

			projectID := args[0]
			directory := projectID // Default to project ID as directory name
			if len(args) > 1 {
				directory = args[1]
			}

			if verbose {
				fmt.Printf("Cloning project: %s\n", projectID)
				fmt.Printf("Into directory: %s\n", directory)
			}

			// Create directory
			if err := os.MkdirAll(directory, 0755); err != nil {
				return fmt.Errorf("failed to create directory: %w", err)
			}

			// Change to the new directory
			if err := os.Chdir(directory); err != nil {
				return fmt.Errorf("failed to change directory: %w", err)
			}

			// Initialize VCS in the directory
			if err := initializeProject(projectID); err != nil {
				return fmt.Errorf("failed to initialize project: %w", err)
			}

			// Get project info and files
			projectInfo, err := getProjectInfo(projectID)
			if err != nil {
				return fmt.Errorf("failed to get project info: %w", err)
			}

			fmt.Printf("üì• Cloning project: %s\n", projectInfo.Name)

			// Get the target branch
			targetBranch := branch
			if targetBranch == "" {
				targetBranch = projectInfo.DefaultBranch
			}

			// Get commit history
			commits, err := getCommitHistory(projectID, targetBranch)
			if err != nil {
				return fmt.Errorf("failed to get commit history: %w", err)
			}

			if len(commits) == 0 {
				fmt.Printf("‚úÖ Empty repository cloned\n")
				return nil
			}

			// Get latest commit
			latestCommit := commits[0]

			// Download all files from the latest commit
			files, err := getCommitFiles(projectID, latestCommit.ID)
			if err != nil {
				return fmt.Errorf("failed to get commit files: %w", err)
			}

			fmt.Printf("üì¶ Downloading %d files...\n", len(files))

			for i, file := range files {
				if verbose {
					fmt.Printf("  [%d/%d] %s\n", i+1, len(files), file.Path)
				}

				if err := downloadFile(file); err != nil {
					fmt.Printf("‚ö†Ô∏è  Failed to download %s: %v\n", file.Path, err)
					continue
				}
			}

			// Initialize local state
			localState := &LocalState{
				ProjectID:     projectID,
				CurrentBranch: targetBranch,
				LocalCommits:  []string{latestCommit.ID},
				RemoteCommits: []string{latestCommit.ID},
				LastSync:      time.Now().Format(time.RFC3339),
				StagedFiles:   make(map[string]FileState),
				LocalRefs:     map[string]string{targetBranch: latestCommit.ID},
			}

			if err := localState.SaveLocalState(); err != nil {
				return fmt.Errorf("failed to save local state: %w", err)
			}

			fmt.Printf("‚úÖ Successfully cloned project '%s'\n", projectInfo.Name)
			fmt.Printf("üìù Branch: %s\n", targetBranch)
			fmt.Printf("üíæ Latest commit: %s\n", latestCommit.ID[:8])
			fmt.Printf("üìÅ %d files downloaded\n", len(files))

			return nil
		},
	}

	cmd.Flags().StringVarP(&branch, "branch", "b", "", "Clone specific branch")
	cmd.Flags().BoolVar(&shallow, "shallow", false, "Shallow clone (latest commit only)")

	return cmd
}

func commitCmd() *cobra.Command {
	var message string
	var addAll bool

	cmd := &cobra.Command{
		Use:   "commit",
		Short: "Create a commit with Git-style optimizations",
		Long: `Create a commit from staged files.

Phase 1 Optimizations:
- Uses Git-style object storage for content
- Leverages local index for fast status checks
- Batch operations for better performance`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runCommitGitStyle(message, addAll)
		},
	}

	cmd.Flags().StringVarP(&message, "message", "m", "", "Commit message")
	cmd.Flags().BoolVarP(&addAll, "all", "a", false, "Add all changes before commit")

	return cmd
}

func pushCmd() *cobra.Command {
	var branch string
	var force bool

	cmd := &cobra.Command{
		Use:   "push [files...]",
		Short: "Push changes to the server",
		RunE: func(cmd *cobra.Command, args []string) error {
			if err := initializeClient(); err != nil {
				return err
			}

			if currentProject == "" {
				return fmt.Errorf("not in a VCS project directory. Run 'vcs init' first")
			}

			// Load local state
			localState, err := LoadLocalState()
			if err != nil {
				return fmt.Errorf("failed to load local state: %w", err)
			}

			// Use provided branch or current branch
			targetBranch := branch
			if targetBranch == "" {
				targetBranch = localState.CurrentBranch
			}
			if targetBranch == "" {
				targetBranch = "main"
			}

			if verbose {
				fmt.Printf("Pushing to branch: %s\n", targetBranch)
			}

			// Get sync status first
			statusResp, err := apiClient.GetSyncStatus(currentProject, targetBranch, localState.LocalCommits)
			if err != nil {
				return fmt.Errorf("failed to get sync status: %w", err)
			}

			var syncStatus struct {
				Success       bool     `json:"success"`
				Status        string   `json:"status"`
				Ahead         int      `json:"ahead"`
				Behind        int      `json:"behind"`
				BehindCommits []string `json:"behind_commits"`
			}

			if err := json.Unmarshal(statusResp, &syncStatus); err != nil {
				return fmt.Errorf("failed to parse sync status: %w", err)
			}

			// Check if we need to pull first
			if syncStatus.Behind > 0 && !force {
				fmt.Printf("‚ö†Ô∏è  Your branch is behind by %d commits. Please run 'vcs pull' first.\n", syncStatus.Behind)
				fmt.Printf("   Or use --force to push anyway (may cause conflicts).\n")
				return nil
			}

			if syncStatus.Ahead == 0 {
				fmt.Println("‚úÖ Everything up-to-date")
				return nil
			}

			// Perform the push
			var filesToPush []string
			if len(args) > 0 {
				filesToPush = args
			}

			pushResp, err := apiClient.PushChanges(currentProject, targetBranch, localState.LocalCommits, localState.RemoteCommits, filesToPush)
			if err != nil {
				return fmt.Errorf("failed to push changes: %w", err)
			}

			var pushResult struct {
				Success      bool     `json:"success"`
				Updated      bool     `json:"updated"`
				NewCommits   []string `json:"new_commits"`
				RequiredPull bool     `json:"required_pull"`
				Conflicts    []string `json:"conflicts"`
			}

			if err := json.Unmarshal(pushResp, &pushResult); err != nil {
				return fmt.Errorf("failed to parse push response: %w", err)
			}

			if !pushResult.Success {
				if pushResult.RequiredPull {
					fmt.Printf("‚ùå Push rejected: remote has newer commits\n")
					fmt.Printf("   Run 'vcs pull' to sync with remote changes first\n")
					return nil
				}
				return fmt.Errorf("push failed: %s", string(pushResp))
			}

			if pushResult.Updated {
				fmt.Printf("‚úÖ Pushed %d commits to %s\n", len(pushResult.NewCommits), targetBranch)
				for _, commitID := range pushResult.NewCommits {
					fmt.Printf("   %s\n", commitID[:8])
				}

				// Update local state - mark pushed commits as remote
				for _, commitID := range pushResult.NewCommits {
					// Add to remote commits list
					found := false
					for _, existing := range localState.RemoteCommits {
						if existing == commitID {
							found = true
							break
						}
					}
					if !found {
						localState.RemoteCommits = append([]string{commitID}, localState.RemoteCommits...)
					}
				}

				// Save updated state
				if err := localState.SaveLocalState(); err != nil {
					fmt.Printf("Warning: failed to save local state: %v\n", err)
				}
			} else {
				fmt.Println("‚úÖ Everything up-to-date")
			}

			return nil
		},
	}

	cmd.Flags().StringVarP(&branch, "branch", "b", "", "Target branch")
	cmd.Flags().BoolVar(&force, "force", false, "Force push even if remote has newer commits")

	return cmd
}

func pullCmd() *cobra.Command {
	var branch string

	cmd := &cobra.Command{
		Use:   "pull",
		Short: "Pull changes from the server",
		RunE: func(cmd *cobra.Command, args []string) error {
			if err := initializeClient(); err != nil {
				return err
			}

			if currentProject == "" {
				return fmt.Errorf("not in a VCS project directory. Run 'vcs init' first")
			}

			// Load local state
			localState, err := LoadLocalState()
			if err != nil {
				return fmt.Errorf("failed to load local state: %w", err)
			}

			// Use provided branch or current branch
			targetBranch := branch
			if targetBranch == "" {
				targetBranch = localState.CurrentBranch
			}
			if targetBranch == "" {
				targetBranch = "main"
			}

			if verbose {
				fmt.Printf("Pulling from branch: %s\n", targetBranch)
			}

			// Perform the pull
			pullResp, err := apiClient.PullChanges(currentProject, targetBranch, localState.LocalCommits, localState.RemoteCommits)
			if err != nil {
				return fmt.Errorf("failed to pull changes: %w", err)
			}

			var pullResult struct {
				Success    bool `json:"success"`
				Updated    bool `json:"updated"`
				NewCommits []struct {
					ID        string `json:"id"`
					Message   string `json:"message"`
					AuthorID  string `json:"author_id"`
					CreatedAt string `json:"created_at"`
				} `json:"new_commits"`
				Files []struct {
					Path        string `json:"path"`
					ContentHash string `json:"content_hash"`
					CommitID    string `json:"commit_id"`
				} `json:"files"`
				HeadCommit string   `json:"head_commit"`
				Conflicts  []string `json:"conflicts"`
			}

			if err := json.Unmarshal(pullResp, &pullResult); err != nil {
				return fmt.Errorf("failed to parse pull response: %w", err)
			}

			if !pullResult.Success {
				return fmt.Errorf("pull failed: %s", string(pullResp))
			}

			if !pullResult.Updated {
				fmt.Println("‚úÖ Already up-to-date")
				return nil
			}

			fmt.Printf("‚úÖ Pulled %d new commits from %s\n", len(pullResult.NewCommits), targetBranch)

			// Show new commits
			for _, commit := range pullResult.NewCommits {
				fmt.Printf("   %s %s (%s)\n",
					commit.ID[:8],
					commit.Message,
					commit.AuthorID)
			}

			// Update local state with new commits
			for _, commit := range pullResult.NewCommits {
				// Add to local commits list
				localState.AddLocalCommit(commit.ID)
				// Also add to remote commits list
				found := false
				for _, existing := range localState.RemoteCommits {
					if existing == commit.ID {
						found = true
						break
					}
				}
				if !found {
					localState.RemoteCommits = append([]string{commit.ID}, localState.RemoteCommits...)
				}
			}

			// Update branch HEAD
			if pullResult.HeadCommit != "" {
				localState.SetBranchHead(targetBranch, pullResult.HeadCommit)
			}

			// Save updated state
			if err := localState.SaveLocalState(); err != nil {
				fmt.Printf("Warning: failed to save local state: %v\n", err)
			}

			// Show file changes
			if len(pullResult.Files) > 0 {
				fmt.Printf("\nUpdated files:\n")
				for _, file := range pullResult.Files {
					fmt.Printf("   %s\n", file.Path)
				}
			}

			return nil
		},
	}

	cmd.Flags().StringVarP(&branch, "branch", "b", "", "Target branch")

	return cmd
}

func branchCmd() *cobra.Command {
	var createBranch string
	var deleteBranch string
	var fromBranch string
	var fromCommit string
	var setDefault bool
	var setProtected bool
	var force bool

	cmd := &cobra.Command{
		Use:   "branch",
		Short: "List, create, or delete branches",
		RunE: func(cmd *cobra.Command, args []string) error {
			if err := initializeClient(); err != nil {
				return err
			}

			if currentProject == "" {
				return fmt.Errorf("not in a VCS project directory. Run 'vcs init' first")
			}

			// Handle branch creation
			if createBranch != "" {
				if verbose {
					fmt.Printf("Creating branch: %s\n", createBranch)
				}

				resp, err := apiClient.CreateBranch(currentProject, createBranch, fromCommit, fromBranch, setProtected)
				if err != nil {
					return fmt.Errorf("failed to create branch: %w", err)
				}

				var createResp struct {
					Success bool `json:"success"`
					Branch  struct {
						Name string `json:"name"`
						ID   string `json:"id"`
					} `json:"branch"`
				}

				if err := json.Unmarshal(resp, &createResp); err != nil {
					return fmt.Errorf("failed to parse create response: %w", err)
				}

				if !createResp.Success {
					return fmt.Errorf("branch creation failed: %s", string(resp))
				}

				fmt.Printf("‚úÖ Created branch '%s'\n", createResp.Branch.Name)

				// Update local state
				localState, err := LoadLocalState()
				if err == nil {
					localState.CurrentBranch = createResp.Branch.Name
					localState.SaveLocalState()
				}

				return nil
			}

			// Handle branch deletion
			if deleteBranch != "" {
				if verbose {
					fmt.Printf("Deleting branch: %s\n", deleteBranch)
				}

				err := apiClient.DeleteBranch(currentProject, deleteBranch, force)
				if err != nil {
					return fmt.Errorf("failed to delete branch: %w", err)
				}

				fmt.Printf("‚úÖ Deleted branch '%s'\n", deleteBranch)
				return nil
			}

			// Handle branch settings updates
			if len(args) > 0 {
				branchName := args[0]
				var isDefault, isProtected *bool

				if cmd.Flags().Changed("set-default") {
					isDefault = &setDefault
				}
				if cmd.Flags().Changed("set-protected") {
					isProtected = &setProtected
				}

				if isDefault != nil || isProtected != nil {
					resp, err := apiClient.UpdateBranch(currentProject, branchName, isDefault, isProtected)
					if err != nil {
						return fmt.Errorf("failed to update branch: %w", err)
					}

					var updateResp struct {
						Success bool   `json:"success"`
						Message string `json:"message"`
					}

					if err := json.Unmarshal(resp, &updateResp); err == nil && updateResp.Success {
						fmt.Printf("‚úÖ %s\n", updateResp.Message)
					} else {
						fmt.Printf("‚úÖ Updated branch '%s'\n", branchName)
					}

					return nil
				}
			}

			// Default action: list branches
			if verbose {
				fmt.Println("Listing branches")
			}

			resp, err := apiClient.ListBranches(currentProject)
			if err != nil {
				return fmt.Errorf("failed to list branches: %w", err)
			}

			var branchResp struct {
				Success  bool `json:"success"`
				Branches []struct {
					Name           string `json:"name"`
					IsDefault      bool   `json:"is_default"`
					IsProtected    bool   `json:"is_protected"`
					LastCommit     string `json:"last_commit"`
					CommitCount    int    `json:"commit_count"`
					LastCommitInfo struct {
						ID        string `json:"id"`
						Message   string `json:"message"`
						AuthorID  string `json:"author_id"`
						CreatedAt string `json:"created_at"`
					} `json:"last_commit_info"`
				} `json:"branches"`
			}

			if err := json.Unmarshal(resp, &branchResp); err != nil {
				return fmt.Errorf("failed to parse branch list: %w", err)
			}

			if !branchResp.Success {
				return fmt.Errorf("failed to get branches: %s", string(resp))
			}

			// Get current branch from local state
			localState, _ := LoadLocalState()
			currentBranch := localState.CurrentBranch
			if currentBranch == "" {
				currentBranch = "main"
			}

			// Display branches
			if len(branchResp.Branches) == 0 {
				fmt.Println("No branches found")
				return nil
			}

			for _, branch := range branchResp.Branches {
				marker := "  "
				if branch.Name == currentBranch {
					marker = "* "
				}

				protectedIndicator := ""
				if branch.IsProtected {
					protectedIndicator = " üîí"
				}

				defaultIndicator := ""
				if branch.IsDefault {
					defaultIndicator = " (default)"
				}

				fmt.Printf("%s%s%s%s", marker, branch.Name, protectedIndicator, defaultIndicator)

				if branch.LastCommit != "" && branch.LastCommitInfo.ID != "" {
					fmt.Printf(" - %s (%s)",
						branch.LastCommitInfo.Message,
						branch.LastCommitInfo.ID[:8])
				}

				if branch.CommitCount > 0 {
					fmt.Printf(" [%d commits]", branch.CommitCount)
				}

				fmt.Println()
			}

			return nil
		},
	}

	cmd.Flags().StringVarP(&createBranch, "create", "c", "", "Create new branch")
	cmd.Flags().StringVarP(&deleteBranch, "delete", "d", "", "Delete branch")
	cmd.Flags().StringVar(&fromBranch, "from-branch", "", "Create branch from another branch")
	cmd.Flags().StringVar(&fromCommit, "from-commit", "", "Create branch from specific commit")
	cmd.Flags().BoolVar(&setDefault, "set-default", false, "Set branch as default")
	cmd.Flags().BoolVar(&setProtected, "set-protected", false, "Set branch as protected")
	cmd.Flags().BoolVar(&force, "force", false, "Force delete protected branch")

	return cmd
}

func initializeProject(projectID string) error {
	// Create .vcs directory
	vcsDir := ".vcs"
	if err := os.MkdirAll(vcsDir, 0755); err != nil {
		return fmt.Errorf("failed to create .vcs directory: %w", err)
	}

	// Create project config
	config := map[string]interface{}{
		"project_id": projectID,
		"server_url": serverURL,
		"cloned_at":  time.Now().Format(time.RFC3339),
		"version":    version,
	}

	configFile := filepath.Join(vcsDir, "config.json")
	configData, _ := json.MarshalIndent(config, "", "  ")
	if err := os.WriteFile(configFile, configData, 0644); err != nil {
		return fmt.Errorf("failed to write config: %w", err)
	}

	return nil
}

func getProjectInfo(projectID string) (*ProjectInfo, error) {
	resp, err := apiClient.makeRequest("GET", fmt.Sprintf("/api/v1/projects/%s", projectID), nil)
	if err != nil {
		return nil, err
	}

	var response struct {
		Success bool        `json:"success"`
		Project ProjectInfo `json:"project"`
	}

	if err := json.Unmarshal(resp, &response); err != nil {
		return nil, err
	}

	if !response.Success {
		return nil, fmt.Errorf("failed to get project info")
	}

	return &response.Project, nil
}

func getCommitHistory(projectID, branch string) ([]CommitInfo, error) {
	url := fmt.Sprintf("/api/v1/commits/%s?branch=%s&limit=50", projectID, branch)
	resp, err := apiClient.makeRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	var response struct {
		Success bool         `json:"success"`
		Commits []CommitInfo `json:"commits"`
	}

	if err := json.Unmarshal(resp, &response); err != nil {
		return nil, err
	}

	if !response.Success {
		return nil, fmt.Errorf("failed to get commit history")
	}

	return response.Commits, nil
}

func getCommitFiles(projectID, commitID string) ([]FileInfo, error) {
	url := fmt.Sprintf("/api/v1/commits/%s/%s", projectID, commitID)
	resp, err := apiClient.makeRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	var response struct {
		Success bool `json:"success"`
		Commit  struct {
			ID    string     `json:"id"`
			Files []FileInfo `json:"files"`
		} `json:"commit"`
	}

	if err := json.Unmarshal(resp, &response); err != nil {
		return nil, err
	}

	if !response.Success {
		return nil, fmt.Errorf("failed to get commit files")
	}

	return response.Commit.Files, nil
}

func downloadFile(file FileInfo) error {
	// Create directory structure
	dir := filepath.Dir(file.Path)
	if dir != "." {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}

	// Download file content
	downloadReq := &fileops.DownloadRequest{
		ContentHash: file.ContentHash,
		ProjectID:   currentProject,
		// UserID:      apiClient.authToken, // This needs to be fixed
	}

	result, err := apiClient.DownloadFile(downloadReq.ContentHash, downloadReq.ProjectID)
	if err != nil {
		return err
	}
	defer result.Close()

	// Write to local file
	localFile, err := os.Create(file.Path)
	if err != nil {
		return err
	}
	defer localFile.Close()

	_, err = io.Copy(localFile, result)
	return err
}

func getEventIcon(eventType string) string {
	switch eventType {
	case "file_locked":
		return "üîí"
	case "file_unlocked":
		return "üîì"
	case "file_modified":
		return "üìù"
	case "user_joined":
		return "üëã"
	case "user_left":
		return "üëã"
	case "commit_created":
		return "üíæ"
	case "conflict_detected":
		return "‚ö†Ô∏è"
	default:
		return "üì°"
	}
}

func formatTime(t time.Time) string {
	now := time.Now()
	diff := now.Sub(t)

	if diff < time.Minute {
		return "just now"
	} else if diff < time.Hour {
		return fmt.Sprintf("%d minutes ago", int(diff.Minutes()))
	} else if diff < 24*time.Hour {
		return fmt.Sprintf("%d hours ago", int(diff.Hours()))
	} else {
		return fmt.Sprintf("%d days ago", int(diff.Hours()/24))
	}
}

func signupCmd() *cobra.Command {
	return &cobra.Command{
		Use:   "signup",
		Short: "Create a new VCS account",
		Long: `Create a new VCS account with username and password.
For Google OAuth, use 'vcs login --google' instead.`,
		RunE: func(cmd *cobra.Command, args []string) error {
			fmt.Printf("üéÆ Welcome to Game Development VCS!\n")
			fmt.Printf("Let's create your account...\n\n")

			// Create a scanner for reading input
			scanner := bufio.NewScanner(os.Stdin)

			// Get user information
			var username, email, name, password string

			// Username
			fmt.Print("üë§ Username: ")
			scanner.Scan()
			username = strings.TrimSpace(scanner.Text())

			// Email
			fmt.Print("üìß Email: ")
			scanner.Scan()
			email = strings.TrimSpace(scanner.Text())

			// Full Name (can contain spaces)
			fmt.Print("üè∑Ô∏è  Full Name: ")
			scanner.Scan()
			name = strings.TrimSpace(scanner.Text())

			// Password (hidden input)
			fmt.Print("üîí Password (min 6 chars): ")
			passwordBytes, err := term.ReadPassword(int(syscall.Stdin))
			if err != nil {
				return fmt.Errorf("failed to read password: %w", err)
			}
			password = strings.TrimSpace(string(passwordBytes))
			fmt.Println() // New line after hidden input

			// Validation
			if username == "" {
				return fmt.Errorf("username is required")
			}
			if email == "" {
				return fmt.Errorf("email is required")
			}
			if name == "" {
				return fmt.Errorf("full name is required")
			}
			if len(password) < 6 {
				return fmt.Errorf("password must be at least 6 characters (you entered %d characters)", len(password))
			}

			// Validate email format (basic)
			if !strings.Contains(email, "@") || !strings.Contains(email, ".") {
				return fmt.Errorf("please enter a valid email address")
			}

			apiClient, err = NewAPIClient(serverURL)
			if err != nil {
				return fmt.Errorf("failed to create API client: %w", err)
			}

			// Perform signup
			signupData := map[string]string{
				"username": username,
				"email":    email,
				"name":     name,
				"password": password,
			}

			fmt.Printf("\nüîÑ Creating account...\n")

			resp, err := apiClient.makeRequest("POST", "/api/v1/auth/signup", signupData)
			if err != nil {
				if strings.Contains(err.Error(), "already exists") {
					return fmt.Errorf("‚ùå Account already exists. Try logging in instead: vcs login")
				}
				if strings.Contains(err.Error(), "connection refused") {
					return fmt.Errorf("‚ùå Cannot connect to server. Is it running? Try: make dev-up")
				}
				return fmt.Errorf("signup failed: %w", err)
			}

			var signupResp struct {
				Success      bool   `json:"success"`
				Token        string `json:"token"`
				RefreshToken string `json:"refresh_token"`
				User         struct {
					ID       string `json:"id"`
					Username string `json:"username"`
					Email    string `json:"email"`
					Name     string `json:"name"`
				} `json:"user"`
				Error string `json:"error"`
			}

			if err := json.Unmarshal(resp, &signupResp); err != nil {
				return fmt.Errorf("failed to parse signup response: %w", err)
			}

			if !signupResp.Success {
				return fmt.Errorf("signup failed: %s", signupResp.Error)
			}

			// Save credentials
			apiClient.SetAuth(signupResp.Token, "")
			if err := saveCredentials(signupResp.Token, ""); err != nil {
				fmt.Printf("Warning: failed to save credentials: %v\n", err)
			}

			fmt.Printf("‚úÖ Account created successfully!\n")
			fmt.Printf("üë§ Welcome, %s!\n", signupResp.User.Name)
			fmt.Printf("üìß Email: %s\n", signupResp.User.Email)
			fmt.Printf("üéØ Username: %s\n", signupResp.User.Username)
			fmt.Printf("\nüöÄ You're now logged in and ready to use VCS!\n")
			fmt.Printf("\nNext steps:\n")
			fmt.Printf("  ‚Ä¢ Check your status: vcs whoami\n")
			fmt.Printf("  ‚Ä¢ Initialize a project: vcs init my-project\n")
			fmt.Printf("  ‚Ä¢ Clone an existing project: vcs clone project-id\n")

			return nil
		},
	}
}

// Add account management commands
func accountCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "account",
		Short: "Manage your VCS account",
		Long:  "Commands for managing your VCS user account",
	}

	cmd.AddCommand(accountInfoCmd())
	cmd.AddCommand(accountUpdateCmd())
	return cmd
}

func accountInfoCmd() *cobra.Command {
	return &cobra.Command{
		Use:   "info",
		Short: "Show detailed account information",
		RunE: func(cmd *cobra.Command, args []string) error {
			// This would show more detailed account info
			return whoamiCmd().RunE(cmd, args)
		},
	}
}

func accountUpdateCmd() *cobra.Command {
	return &cobra.Command{
		Use:   "update",
		Short: "Update account information",
		RunE: func(cmd *cobra.Command, args []string) error {
			fmt.Printf("üîß Account update functionality coming soon!\n")
			fmt.Printf("For now, use the web dashboard to update your account.\n")
			return nil
		},
	}
}

func getAllFilesRespectingIgnore() ([]string, error) {
	ignorePatterns, err := loadVCSIgnorePatterns()
	if err != nil {
		return nil, err
	}

	var files []string
	err = filepath.Walk(".", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip directories
		if info.IsDir() {
			return nil
		}

		// Normalize path (remove leading ./)
		cleanPath := strings.TrimPrefix(path, "./")
		if cleanPath == "." {
			cleanPath = path
		}

		// Check if file should be ignored
		if shouldIgnoreFile(cleanPath, ignorePatterns) {
			if verbose {
				fmt.Printf("üôà Ignoring: %s\n", cleanPath)
			}
			return nil
		}

		files = append(files, cleanPath)
		return nil
	})

	return files, err
}

func loadVCSIgnorePatterns() ([]string, error) {
	var patterns []string

	// Check if .vcsignore exists
	if _, err := os.Stat(".vcsignore"); os.IsNotExist(err) {
		if verbose {
			fmt.Println("üìù No .vcsignore found, using default patterns")
		}
		return defaultVCSIgnorePatterns, nil
	}

	// Read .vcsignore file
	file, err := os.Open(".vcsignore")
	if err != nil {
		return nil, fmt.Errorf("failed to open .vcsignore: %w", err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		// Skip empty lines and comments (but keep pattern comments)
		if line != "" {
			patterns = append(patterns, line)
		}
	}

	if verbose {
		fmt.Printf("üìù Loaded %d patterns from .vcsignore\n", len(patterns))
	}

	return patterns, scanner.Err()
}

// shouldIgnoreFile checks if a file matches any ignore patterns
func shouldIgnoreFile(filePath string, patterns []string) bool {
	for _, pattern := range patterns {
		// Skip comment lines
		if strings.HasPrefix(pattern, "#") {
			continue
		}

		// Handle negation patterns (!)
		if strings.HasPrefix(pattern, "!") {
			// Remove the ! and check if it matches
			positivePattern := strings.TrimPrefix(pattern, "!")
			if matchesPattern(filePath, positivePattern) {
				return false // Don't ignore this file
			}
			continue
		}

		// Check if file matches the pattern
		if matchesPattern(filePath, pattern) {
			return true
		}
	}
	return false
}

// matchesPattern checks if a file path matches a gitignore-style pattern
func matchesPattern(filePath, pattern string) bool {
	// Remove trailing slash from pattern for directory matching
	pattern = strings.TrimSuffix(pattern, "/")

	// Handle directory-only patterns (ending with /)
	if strings.HasSuffix(pattern, "/") {
		// This pattern only matches directories, skip for files
		return false
	}

	// Handle wildcard patterns
	if strings.Contains(pattern, "*") {
		matched, _ := filepath.Match(pattern, filePath)
		if matched {
			return true
		}

		// Also check if any parent directory matches
		dir := filepath.Dir(filePath)
		for dir != "." && dir != "/" {
			matched, _ := filepath.Match(pattern, filepath.Base(dir))
			if matched {
				return true
			}
			dir = filepath.Dir(dir)
		}

		// Handle ** patterns (match multiple directory levels)
		if strings.Contains(pattern, "**") {
			// Simple ** pattern matching
			patternParts := strings.Split(pattern, "**")
			if len(patternParts) == 2 {
				prefix := patternParts[0]
				suffix := patternParts[1]

				if strings.HasPrefix(filePath, prefix) && strings.HasSuffix(filePath, suffix) {
					return true
				}
			}
		}

		return false
	}

	// Exact match
	if filePath == pattern {
		return true
	}

	// Check if any parent directory matches
	if strings.Contains(filePath, pattern+"/") {
		return true
	}

	return false
}

// initVCSCmd initializes a new VCS repository
func initVCSCmd() *cobra.Command {
	var projectName string
	var description string
	var isPrivate bool
	var force bool

	cmd := &cobra.Command{
		Use:   "init [project-name]",
		Short: "Initialize a new VCS repository",
		Long: `Initialize a new VCS repository in the current directory.
Creates local .vcs directory structure, .vcsignore file, and registers project with VCS server.

Examples:
  vcs init                              # Initialize with directory name as project
  vcs init MyProject                    # Initialize with specific project name
  vcs init MyProject --private          # Initialize as private project
  vcs init --description "My UE5 game"  # Initialize with description`,
		Args: cobra.MaximumNArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			if len(args) > 0 {
				projectName = args[0]
			}
			return runVCSInit(projectName, description, isPrivate, force)
		},
	}

	cmd.Flags().StringVarP(&description, "description", "d", "", "Project description")
	cmd.Flags().BoolVarP(&isPrivate, "private", "p", true, "Make project private (default: true)")
	cmd.Flags().BoolVar(&force, "force", false, "Force initialization even if VCS already exists")

	return cmd
}

// Enhanced migrateCmd to accept project options
func migrateCmd() *cobra.Command {
	var force bool
	var keepGit bool
	var description string
	var isPrivate bool

	cmd := &cobra.Command{
		Use:   "migrate",
		Short: "Migrate from Git to VCS",
		Long: `Migrate a Git repository to VCS by:
- Creating project on VCS server
- Removing .git directory (unless --keep-git is specified)
- Creating .vcs directory structure
- Converting .gitignore to .vcsignore (or creating default)
- Initializing VCS project

Examples:
  vcs migrate                           # Migrate current Git repo to VCS
  vcs migrate --keep-git                # Migrate but keep .git directory
  vcs migrate --force                   # Force migration even if VCS already exists
  vcs migrate --description "My game"   # Add custom description
  vcs migrate --public                  # Make project public instead of private`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runMigrationWithOptions(force, keepGit, description, !isPrivate) // Note: !isPrivate because flag is --public
		},
	}

	cmd.Flags().BoolVar(&force, "force", false, "Force migration even if VCS already initialized")
	cmd.Flags().BoolVar(&keepGit, "keep-git", false, "Keep .git directory after migration")
	cmd.Flags().StringVarP(&description, "description", "d", "", "Project description (default: 'Migrated from Git repository')")
	cmd.Flags().BoolVar(&isPrivate, "public", false, "Make project public (default: private)")

	return cmd
}

// runMigrationWithOptions allows customizing migration options
func runMigrationWithOptions(force, keepGit bool, description string, isPrivate bool) error {
	fmt.Println("üîÑ Starting Git to VCS migration...")

	// Check if we're in a Git repository
	if _, err := os.Stat(".git"); os.IsNotExist(err) {
		fmt.Println("‚ùå No .git directory found. This doesn't appear to be a Git repository.")
		fmt.Println("üí° Use 'vcs init' to initialize a new VCS repository.")
		return nil
	}

	// Check if VCS already exists
	if _, err := os.Stat(".vcs"); err == nil && !force {
		fmt.Println("‚ùå VCS repository already exists. Use --force to overwrite.")
		return nil
	}

	// Get project name from current directory
	currentDir, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get current directory: %w", err)
	}
	projectName := filepath.Base(currentDir)

	// Use default description if none provided
	if description == "" {
		description = "Migrated from Git repository"
	}

	fmt.Printf("üìÅ Project: %s\n", projectName)

	// Initialize API client to connect to server
	if err := initializeClient(); err != nil {
		return fmt.Errorf("failed to connect to VCS server: %w", err)
	}

	// Create project on server
	fmt.Println("üì° Creating project on VCS server...")

	project, err := createProjectOnServer(projectName, description, isPrivate)
	if err != nil {
		return fmt.Errorf("failed to create project on server: %w", err)
	}

	fmt.Printf("‚úÖ Project created on server: %s (ID: %s)\n", project.Name, project.ID)

	// Step 1: Convert .gitignore to .vcsignore
	if err := convertGitignoreToVCSIgnore(); err != nil {
		fmt.Printf("‚ö†Ô∏è  Warning: Failed to convert .gitignore: %v\n", err)
	}

	// Step 2: Initialize VCS structure with the actual project ID
	if err := createVCSStructure(project.Name, project.ID); err != nil {
		return fmt.Errorf("failed to create VCS structure: %w", err)
	}

	// Step 3: Save project config locally
	if err := saveProjectConfig(project); err != nil {
		fmt.Printf("‚ö†Ô∏è  Warning: Failed to save project config: %v\n", err)
	}

	// Step 4: Remove .git directory (unless keeping it)
	if !keepGit {
		fmt.Println("üóëÔ∏è  Removing .git directory...")
		if err := os.RemoveAll(".git"); err != nil {
			fmt.Printf("‚ö†Ô∏è  Warning: Failed to remove .git directory: %v\n", err)
		} else {
			fmt.Println("‚úÖ Removed .git directory")
		}
	} else {
		fmt.Println("üìÅ Keeping .git directory as requested")
	}

	fmt.Println("\nüéâ Migration completed successfully!")
	fmt.Printf("üìÅ Project: %s\n", project.Name)
	fmt.Printf("üîí Privacy: %s\n", func() string {
		if project.IsPrivate {
			return "Private"
		}
		return "Public"
	}())
	fmt.Printf("üÜî Project ID: %s\n", project.ID)
	fmt.Println("\nüìù Next steps:")
	fmt.Println("   1. Review and edit .vcsignore if needed")
	fmt.Println("   2. Add your files: vcs add -a")
	fmt.Println("   3. Create your first commit: vcs commit -m \"Initial commit\"")

	return nil
}

// runVCSInit initializes a new VCS repository
func runVCSInit(projectName, description string, isPrivate, force bool) error {
	// Get project name from directory if not provided
	if projectName == "" {
		currentDir, err := os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get current directory: %w", err)
		}
		projectName = filepath.Base(currentDir)
	}

	fmt.Printf("üöÄ Initializing VCS repository: %s\n", projectName)
	fmt.Printf("üîç Debug: Current directory: %s\n", func() string {
		if dir, err := os.Getwd(); err == nil {
			return dir
		}
		return "unknown"
	}())

	// Check if VCS already exists
	if _, err := os.Stat(".vcs"); err == nil && !force {
		fmt.Println("‚ùå VCS repository already exists. Use --force to overwrite.")
		return nil
	}

	// Initialize API client
	fmt.Println("üîç Debug: Initializing API client...")
	if err := initializeClient(); err != nil {
		return fmt.Errorf("failed to connect to VCS server: %w", err)
	}
	fmt.Println("‚úÖ API client initialized")

	// Create project on server
	fmt.Println("üì° Creating project on VCS server...")
	project, err := createProjectOnServer(projectName, description, isPrivate)
	if err != nil {
		return fmt.Errorf("failed to create project on server: %w", err)
	}

	fmt.Printf("‚úÖ Project created on server: %s (ID: %s)\n", project.Name, project.ID)

	// Create local VCS structure
	fmt.Println("üìÅ Creating local VCS directory structure...")
	if err := createVCSStructure(project.Name, project.ID); err != nil {
		return fmt.Errorf("failed to create local VCS structure: %w", err)
	}

	// Create default .vcsignore
	fmt.Println("üìù Creating default .vcsignore...")
	if err := createDefaultVCSIgnore(); err != nil {
		fmt.Printf("‚ö†Ô∏è  Warning: Failed to create .vcsignore: %v\n", err)
	} else {
		fmt.Println("‚úÖ Created .vcsignore with UE5 template")
	}

	// Save project config locally
	fmt.Println("üíæ Saving project config...")
	if err := saveProjectConfig(project); err != nil {
		fmt.Printf("‚ùå CRITICAL: Failed to save project config: %v\n", err)
		return fmt.Errorf("failed to save project config: %w", err)
	} else {
		fmt.Println("‚úÖ Project config saved successfully")
	}

	// Verify the file was created
	if _, err := os.Stat(".vcs/project.json"); err != nil {
		fmt.Printf("‚ùå CRITICAL: .vcs/project.json was not created: %v\n", err)
		return fmt.Errorf(".vcs/project.json was not created")
	} else {
		fmt.Println("‚úÖ Verified .vcs/project.json exists")
	}

	fmt.Println("\n‚úÖ VCS repository initialized successfully!")
	fmt.Printf("üìÅ Project: %s\n", project.Name)
	fmt.Printf("üîí Privacy: %s\n", func() string {
		if project.IsPrivate {
			return "Private"
		}
		return "Public"
	}())
	fmt.Println("\nüìù Next steps:")
	fmt.Println("   1. Add your files: vcs add -a")
	fmt.Println("   2. Create your first commit: vcs commit -m \"Initial commit\"")
	fmt.Println("   3. Check status: vcs status")

	return nil
}

func createProjectOnServer(name, description string, isPrivate bool) (*Project, error) {
	requestData := map[string]interface{}{
		"name":        name,
		"description": description,
		"is_private":  isPrivate,
	}

	resp, err := apiClient.makeRequest("POST", "/api/v1/projects", requestData)
	if err != nil {
		return nil, err
	}

	var response struct {
		Success bool    `json:"success"`
		Project Project `json:"project"`
		Error   string  `json:"error"`
	}

	if err := json.Unmarshal(resp, &response); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	if !response.Success {
		return nil, fmt.Errorf("server error: %s", response.Error)
	}

	return &response.Project, nil
}

func createVCSStructure(projectName, projectID string) error {
	fmt.Println("üìÅ Creating local VCS directory structure...")

	// Create .vcs directory
	vcsDir := ".vcs"
	if err := os.MkdirAll(vcsDir, 0755); err != nil {
		return fmt.Errorf("failed to create .vcs directory: %w", err)
	}

	// Create subdirectories
	subdirs := []string{
		"objects", // For storing file objects
		"refs",    // For storing references
		"logs",    // For operation logs
		"cache",   // For temporary cache
		"hooks",   // For hooks (future feature)
	}

	for _, subdir := range subdirs {
		fullPath := filepath.Join(vcsDir, subdir)
		if err := os.MkdirAll(fullPath, 0755); err != nil {
			return fmt.Errorf("failed to create %s directory: %w", fullPath, err)
		}
	}

	// Create VCS config file with project ID
	configContent := fmt.Sprintf(`{
  "project_id": "%s",
  "project_name": "%s",
  "version": "1.0",
  "created_at": "%s",
  "remote_url": "",
  "default_branch": "main"
}`, projectID, projectName, "2025-06-24T22:30:00Z")

	configPath := filepath.Join(vcsDir, "config.json")
	if err := os.WriteFile(configPath, []byte(configContent), 0644); err != nil {
		return fmt.Errorf("failed to create VCS config: %w", err)
	}

	// Create HEAD file (current branch reference)
	headContent := "ref: refs/heads/main\n"
	headPath := filepath.Join(vcsDir, "HEAD")
	if err := os.WriteFile(headPath, []byte(headContent), 0644); err != nil {
		return fmt.Errorf("failed to create HEAD file: %w", err)
	}

	fmt.Println("‚úÖ Created local VCS directory structure")
	return nil
}

// convertGitignoreToVCSIgnore converts .gitignore to .vcsignore
func convertGitignoreToVCSIgnore() error {
	fmt.Println("üìù Converting .gitignore to .vcsignore...")

	// Check if .gitignore exists
	if _, err := os.Stat(".gitignore"); os.IsNotExist(err) {
		fmt.Println("üìÑ No .gitignore found, creating default .vcsignore")
		return createDefaultVCSIgnore()
	}

	// Read .gitignore
	gitignoreContent, err := os.ReadFile(".gitignore")
	if err != nil {
		return fmt.Errorf("failed to read .gitignore: %w", err)
	}

	// Convert content
	vcsignoreContent := string(gitignoreContent)

	// Add VCS-specific patterns
	vcsignoreContent += "\n\n# VCS specific files\n"
	vcsignoreContent += ".vcs/\n"
	vcsignoreContent += "*.vcs.tmp\n"
	vcsignoreContent += ".vcs-cache/\n"

	// Write .vcsignore
	if err := os.WriteFile(".vcsignore", []byte(vcsignoreContent), 0644); err != nil {
		return fmt.Errorf("failed to write .vcsignore: %w", err)
	}

	fmt.Println("‚úÖ Converted .gitignore to .vcsignore")
	return nil
}

// createDefaultVCSIgnore creates a default .vcsignore file
func createDefaultVCSIgnore() error {
	fmt.Println("üìù Creating default .vcsignore...")

	content := strings.Join(defaultVCSIgnorePatterns, "\n")

	if err := os.WriteFile(".vcsignore", []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to create .vcsignore: %w", err)
	}

	fmt.Println("‚úÖ Created .vcsignore with UE5 template")
	return nil
}

func saveProjectConfig(project *Project) error {
	fmt.Printf("üîç Debug: Saving project config for project ID: %s\n", project.ID)

	config := map[string]interface{}{
		"project_id":   project.ID,
		"project_name": project.Name,
		"slug":         project.Slug,
		"is_private":   project.IsPrivate,
		"server_url":   serverURL,
	}

	fmt.Printf("üîç Debug: Config data: %+v\n", config)

	configData, err := json.MarshalIndent(config, "", "  ")
	if err != nil {
		fmt.Printf("‚ùå Debug: Failed to marshal config: %v\n", err)
		return err
	}

	fmt.Printf("üîç Debug: Writing to .vcs/project.json\n")
	fmt.Printf("üîç Debug: Config JSON: %s\n", string(configData))

	// Make sure .vcs directory exists
	if err := os.MkdirAll(".vcs", 0755); err != nil {
		fmt.Printf("‚ùå Debug: Failed to create .vcs directory: %v\n", err)
		return err
	}

	if err := os.WriteFile(".vcs/project.json", configData, 0644); err != nil {
		fmt.Printf("‚ùå Debug: Failed to write .vcs/project.json: %v\n", err)
		return err
	}

	fmt.Println("‚úÖ Debug: Successfully wrote .vcs/project.json")
	return nil
}

// cleanCmd removes VCS and optionally restores Git
func cleanCmd() *cobra.Command {
	var restoreGit bool

	cmd := &cobra.Command{
		Use:   "clean",
		Short: "Remove VCS files from the repository",
		Long: `Remove VCS files and directories from the current repository.
Optionally restore Git if a backup exists.

Examples:
  vcs clean                    # Remove VCS files
  vcs clean --restore-git      # Remove VCS and restore Git`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runClean(restoreGit)
		},
	}

	cmd.Flags().BoolVar(&restoreGit, "restore-git", false, "Restore Git repository if backup exists")

	return cmd
}

// runClean removes VCS files
func runClean(restoreGit bool) error {
	fmt.Println("üßπ Cleaning VCS files...")

	// Remove .vcs directory
	if _, err := os.Stat(".vcs"); err == nil {
		if err := os.RemoveAll(".vcs"); err != nil {
			return fmt.Errorf("failed to remove .vcs directory: %w", err)
		}
		fmt.Println("‚úÖ Removed .vcs directory")
	}

	// Remove .vcsignore
	if _, err := os.Stat(".vcsignore"); err == nil {
		if err := os.Remove(".vcsignore"); err != nil {
			fmt.Printf("‚ö†Ô∏è  Warning: Failed to remove .vcsignore: %v\n", err)
		} else {
			fmt.Println("‚úÖ Removed .vcsignore")
		}
	}

	if restoreGit {
		fmt.Println("üîÑ Git restoration not implemented yet")
		// TODO: Implement Git restoration from backup if needed
	}

	fmt.Println("‚úÖ VCS cleanup completed")
	return nil
}

// verifyProjectExists checks if project exists on server
func verifyProjectExists(projectID string) error {
	resp, err := apiClient.makeRequest("GET", fmt.Sprintf("/api/v1/projects/%s/exists", projectID), nil)
	if err != nil {
		return err
	}

	var response struct {
		Success bool `json:"success"`
		Exists  bool `json:"exists"`
	}

	if err := json.Unmarshal(resp, &response); err != nil {
		return fmt.Errorf("failed to parse response: %w", err)
	}

	if !response.Success || !response.Exists {
		return fmt.Errorf("project does not exist on server")
	}

	return nil
}

func runAddGitStyle(args []string, addAll, verbose bool) error {
	// Load project configuration
	config, err := LoadProjectConfig()
	if err != nil {
		return fmt.Errorf("failed to load project config. Run 'vcs init' first: %w", err)
	}

	projectID, ok := config["project_id"].(string)
	if !ok || projectID == "" {
		return fmt.Errorf("invalid project configuration. Run 'vcs init' to fix")
	}

	// Initialize API client with Git-style storage
	if err := initializeClient(); err != nil {
		return fmt.Errorf("failed to connect to VCS server: %w", err)
	}

	// Verify project exists on server
	if err := verifyProjectExists(projectID); err != nil {
		return fmt.Errorf("project not found on server: %w", err)
	}

	// Determine files to process
	var filesToAdd []string

	if addAll {
		fmt.Printf("üîç Discovering files (respecting .vcsignore)...\n")
		files, err := getAllFilesRespectingIgnore()
		if err != nil {
			return fmt.Errorf("failed to get files: %w", err)
		}
		filesToAdd = files
		fmt.Printf("üìÅ Found %d files to consider\n", len(filesToAdd))
	} else {
		if len(args) == 0 {
			return fmt.Errorf("specify files to add or use -a to add all files")
		}
		filesToAdd = args
		fmt.Printf("üìÅ Processing %d specified files\n", len(filesToAdd))
	}

	if len(filesToAdd) == 0 {
		fmt.Printf("‚úÖ No files to add\n")
		return nil
	}

	// PHASE 1: Git-style batch processing
	fmt.Printf("\nüöÄ Starting Git-style batch processing...\n")
	// start := time.Now()

	batchResult, err := apiClient.ProcessFilesBatchGitStyle(projectID, filesToAdd)
	if err != nil {
		return fmt.Errorf("batch processing failed: %w", err)
	}

	// Display results
	fmt.Printf("\nüìä Processing Summary:\n")
	fmt.Printf("   Total files: %d\n", batchResult.TotalFiles)
	fmt.Printf("   Processed: %d\n", batchResult.ProcessedFiles)
	fmt.Printf("   Skipped (unchanged): %d\n", batchResult.SkippedFiles)
	fmt.Printf("   Failed: %d\n", batchResult.FailedFiles)
	fmt.Printf("   Objects stored: %d\n", len(batchResult.ObjectsStored))
	fmt.Printf("   Total time: %v\n", batchResult.Duration)

	if len(batchResult.ObjectsStored) > 0 {
		var totalSize int64
		var totalCompressed int64
		for _, obj := range batchResult.ObjectsStored {
			totalSize += obj.Size
			totalCompressed += obj.CompressedSize
		}
		compressionRatio := float64(totalCompressed) / float64(totalSize) * 100
		fmt.Printf("   Compression: %.1f%% (saved %s)\n",
			compressionRatio, FormatFileSize(totalSize-totalCompressed))
	}

	// Show detailed results if verbose
	if verbose && len(batchResult.Results) > 0 {
		fmt.Printf("\nüìã Detailed Results:\n")
		for _, result := range batchResult.Results {
			if result.Success {
				if result.Skipped {
					fmt.Printf("   ‚è≠Ô∏è  %s (unchanged)\n", result.FilePath)
				} else {
					fmt.Printf("   ‚úÖ %s (%s)\n",
						result.FilePath, FormatFileSize(result.Size))
				}
			} else {
				fmt.Printf("   ‚ùå %s - %v\n", result.FilePath, result.Error)
			}
		}
	}

	// Update local staging state
	localState, err := LoadLocalState()
	if err != nil {
		// Create new local state if it doesn't exist
		localState = &LocalState{
			StagedFiles: make(map[string]FileState),
		}
	}

	// Mark successfully processed files as staged
	for _, result := range batchResult.Results {
		if result.Success && !result.Skipped {
			localState.AddStagedFile(result.FilePath)
		}
	}

	if err := SaveLocalState(localState); err != nil {
		fmt.Printf("‚ö†Ô∏è  Warning: Failed to save local state: %v\n", err)
	}

	// Show performance comparison
	estimatedOldTime := time.Duration(len(filesToAdd)) * 500 * time.Millisecond // Estimate old per-file time
	speedup := float64(estimatedOldTime) / float64(batchResult.Duration)

	fmt.Printf("\nüéØ Performance Impact:\n")
	fmt.Printf("   Estimated old time: %v\n", estimatedOldTime)
	fmt.Printf("   Actual time: %v\n", batchResult.Duration)
	fmt.Printf("   Speedup: %.1fx faster\n", speedup)

	if batchResult.FailedFiles > 0 {
		fmt.Printf("\n‚ö†Ô∏è  %d files failed to process. Use --verbose to see details.\n", batchResult.FailedFiles)
		return fmt.Errorf("some files failed to process")
	}

	fmt.Printf("\n‚úÖ All files processed successfully!\n")
	fmt.Printf("üí° Next step: vcs commit -m \"Your commit message\"\n")

	return nil
}

func runStatusGitStyle(verbose bool) error {
	// Load project configuration
	config, err := LoadProjectConfig()
	if err != nil {
		return fmt.Errorf("not a VCS repository. Run 'vcs init' first")
	}

	projectID, ok := config["project_id"].(string)
	if !ok {
		return fmt.Errorf("invalid project configuration")
	}

	// Initialize client
	if err := initializeClient(); err != nil {
		return fmt.Errorf("failed to initialize client: %w", err)
	}

	fmt.Printf("üìä VCS Status (Git-style optimizations enabled)\n")
	fmt.Printf("Project: %s\n\n", projectID)

	// Get local file index stats
	indexStats := apiClient.GetIndexStats()
	fmt.Printf("üìÇ Local Index Statistics:\n")
	if indexStats["error"] != nil {
		fmt.Printf("   ‚ö†Ô∏è  Index error: %v\n", indexStats["error"])
	} else {
		fmt.Printf("   Total entries: %v\n", indexStats["total_entries"])
		fmt.Printf("   Staged entries: %v\n", indexStats["staged_entries"])
		fmt.Printf("   Total size: %s\n", FormatFileSize(indexStats["total_size"].(int64)))
	}

	// Get object store stats
	if verbose {
		objectStats, err := apiClient.GetObjectStoreStats()
		if err != nil {
			fmt.Printf("\n‚ö†Ô∏è  Object store error: %v\n", err)
		} else {
			fmt.Printf("\nüóÑÔ∏è  Object Store Statistics:\n")
			fmt.Printf("   Total objects: %v\n", objectStats["total_objects"])
			fmt.Printf("   Total size: %s\n", FormatFileSize(objectStats["total_size"].(int64)))
			fmt.Printf("   Compressed size: %s\n", FormatFileSize(objectStats["total_compressed"].(int64)))
			fmt.Printf("   Compression ratio: %.1f%%\n", objectStats["compression_ratio"].(float64)*100)
			fmt.Printf("   Space saved: %s\n", FormatFileSize(objectStats["space_saved"].(int64)))
		}
	}

	// Load local state
	localState, err := LoadLocalState()
	if err != nil {
		fmt.Printf("\n‚ö†Ô∏è  No local state found\n")
		return nil
	}

	// Show staged files
	stagedFiles := localState.GetStagedFiles()
	if len(stagedFiles) > 0 {
		fmt.Printf("\nüìù Staged Files (%d):\n", len(stagedFiles))
		for _, filePath := range stagedFiles {
			fmt.Printf("   ‚úÖ %s\n", filePath)
		}
	} else {
		fmt.Printf("\nüìù No files staged for commit\n")
	}

	// Quick change detection on common files
	if verbose {
		fmt.Printf("\nüîç Quick Change Detection:\n")
		commonFiles, _ := getAllFilesRespectingIgnore()
		if len(commonFiles) > 10 {
			commonFiles = commonFiles[:10] // Sample first 10 files
		}

		for _, filePath := range commonFiles {
			if _, err := os.Stat(filePath); err == nil {
				// This would use the index to quickly check if file changed
				fmt.Printf("   üìÑ %s (checking...)\n", filePath)
			}
		}
	}

	fmt.Printf("\nüí° Git-style optimizations active:\n")
	fmt.Printf("   ‚ö° Stat-based change detection\n")
	fmt.Printf("   üóÑÔ∏è  Content-addressable storage\n")
	fmt.Printf("   üì¶ Object compression\n")
	fmt.Printf("   üöÄ Batch processing\n")

	return nil
}

func cleanupCmd() *cobra.Command {
	var aggressive bool

	cmd := &cobra.Command{
		Use:   "cleanup",
		Short: "Clean up local Git-style storage",
		Long: `Clean up unused objects and optimize local storage.

This command:
- Removes unreferenced objects from the object store
- Cleans up stale index entries
- Optimizes storage compression
- Reports space savings`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runCleanupGitStyle(aggressive)
		},
	}

	cmd.Flags().BoolVar(&aggressive, "aggressive", false, "Perform aggressive cleanup")

	return cmd
}

// runCleanupGitStyle performs Git-style cleanup operations
func runCleanupGitStyle(bool) error {
	fmt.Printf("üßπ Starting Git-style cleanup...\n")

	// Initialize client
	if err := initializeClient(); err != nil {
		return fmt.Errorf("failed to initialize client: %w", err)
	}

	// Get stats before cleanup
	beforeStats, err := apiClient.GetObjectStoreStats()
	if err != nil {
		fmt.Printf("‚ö†Ô∏è  Failed to get before stats: %v\n", err)
	}

	// Perform cleanup
	if err := apiClient.CleanupLocalStorage(); err != nil {
		return fmt.Errorf("cleanup failed: %w", err)
	}

	// Get stats after cleanup
	afterStats, err := apiClient.GetObjectStoreStats()
	if err != nil {
		fmt.Printf("‚ö†Ô∏è  Failed to get after stats: %v\n", err)
	}

	// Report results
	if beforeStats != nil && afterStats != nil {
		beforeObjects := beforeStats["total_objects"].(int64)
		afterObjects := afterStats["total_objects"].(int64)
		beforeSize := beforeStats["total_compressed"].(int64)
		afterSize := afterStats["total_compressed"].(int64)

		fmt.Printf("‚úÖ Cleanup completed:\n")
		fmt.Printf("   Objects: %d ‚Üí %d (removed %d)\n",
			beforeObjects, afterObjects, beforeObjects-afterObjects)
		fmt.Printf("   Storage: %s ‚Üí %s (saved %s)\n",
			FormatFileSize(beforeSize), FormatFileSize(afterSize),
			FormatFileSize(beforeSize-afterSize))
	}

	fmt.Printf("üéØ Local storage optimized!\n")
	return nil
}

func runCommitGitStyle(message string, addAll bool) error {
	if message == "" {
		return fmt.Errorf("commit message is required. Use -m flag")
	}

	// Auto-add if requested
	if addAll {
		fmt.Printf("üîÑ Auto-adding all changes...\n")
		if err := runAddGitStyle([]string{}, true, false); err != nil {
			return fmt.Errorf("failed to add files: %w", err)
		}
	}

	// Load project config
	config, err := LoadProjectConfig()
	if err != nil {
		return fmt.Errorf("not a VCS repository")
	}

	projectID := config["project_id"].(string)

	// Initialize client
	if err := initializeClient(); err != nil {
		return fmt.Errorf("failed to initialize client: %w", err)
	}

	// Get staged files from local state
	localState, err := LoadLocalState()
	if err != nil {
		return fmt.Errorf("failed to load local state: %w", err)
	}

	stagedFiles := localState.GetStagedFiles()
	if len(stagedFiles) == 0 {
		fmt.Printf("üìù No files staged for commit\n")
		fmt.Printf("üí° Use 'vcs add' to stage files first\n")
		return nil
	}

	fmt.Printf("üöÄ Creating commit with %d staged files...\n", len(stagedFiles))
	fmt.Printf("üìù Message: %s\n", message)

	// STEP 1: Upload staged files to server first
	fmt.Printf("üì§ Uploading %d staged files to server...\n", len(stagedFiles))

	// Convert staged files to file paths
	filePaths := append([]string{}, stagedFiles...)

	// Force upload all staged files (bypass stat optimization for commit)
	fmt.Printf("üîÑ Processing all staged files for commit...\n")

	// Upload files using batch processing with forced processing for commit
	uploadResult, err := apiClient.ProcessFilesBatchGitStyleForCommit(projectID, filePaths)
	if err != nil {
		return fmt.Errorf("failed to upload staged files: %w", err)
	}

	fmt.Printf("‚úÖ Uploaded %d files (%d processed, %d skipped)\n",
		uploadResult.ProcessedFiles, uploadResult.ProcessedFiles, uploadResult.SkippedFiles)

	// STEP 2: Create commit with uploaded files
	commitData := map[string]interface{}{
		"message":    message,
		"file_paths": filePaths, // Add the file paths to the commit request
		"branch":     "main",
	}

	// Use project ID in URL path, not body
	url := fmt.Sprintf("/api/v1/commits/%s", projectID)
	resp, err := apiClient.makeRequest("POST", url, commitData)
	if err != nil {
		return fmt.Errorf("failed to create commit: %w", err)
	}

	var commitResp struct {
		Success bool `json:"success"`
		Commit  struct {
			ID        string `json:"id"`
			Message   string `json:"message"`
			CreatedAt string `json:"created_at"`
		} `json:"commit"`
		Error string `json:"error"`
	}

	if err := json.Unmarshal(resp, &commitResp); err != nil {
		return fmt.Errorf("failed to parse commit response: %w", err)
	}

	if !commitResp.Success {
		return fmt.Errorf("commit failed: %s", commitResp.Error)
	}

	fmt.Printf("‚úÖ Commit created: %s\n", commitResp.Commit.ID)
	fmt.Printf("üìÖ Created at: %s\n", commitResp.Commit.CreatedAt)

	// Clear staged files from local state
	if localState != nil {
		localState.ClearStagedFiles()
		SaveLocalState(localState)
	}

	// Mark files as unstaged in index
	// This would be implemented in Phase 2 with proper index management

	return nil
}

func FormatFileSize(bytes int64) string {
	const unit = 1024
	if bytes < unit {
		return fmt.Sprintf("%d B", bytes)
	}
	div, exp := int64(unit), 0
	for n := bytes / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])
}
